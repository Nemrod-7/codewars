#include <iostream>
#include <iomanip>
#include <sstream>
#include <fstream>

#include <vector>
#include <queue>
#include <cmath>
#include <algorithm>
#include <numeric>
#include <limits>

#include <chrono>
// NEQ5xBztxeg43aP
using namespace std;

vector<vector<int>> getfile (string str) {
    int num;
    string buff;
    fstream file (str);
    vector<vector<int>> mat;

    while (getline (file, buff)) {
        stringstream line (buff);
        vector<int> ve;

        while (line >> num)
            ve.push_back(num);

        mat.push_back(ve);
    }

    file.close();
    return mat;
}

vector<uint64_t> sieve (uint64_t num) {

    bool *primes = new bool[num + 1];
    vector<uint64_t> sieve {2};

    fill_n (primes, num + 1, true);

    for (uint64_t p = 3; p * p <= num ; p += 2) {
        if (primes[p] == true) {
            for (uint64_t i = p * p; i <= num; i += 2 * p) {
                primes[i] = false;
            }
        }
    }

    for (uint64_t i = 3; i <= num; i += 2) {
        if (primes[i] == true) {
            sieve.push_back(i);
        }
    }

    delete[] primes;
    return sieve;
}
uint64_t tau (uint64_t n) { // count number of divisors
    uint64_t total = 1;

    for (; (n & 1) == 0; n >>= 1) // Deal with powers of 2 first
        ++total;

    for (uint64_t p = 3; p * p <= n; p += 2) { // Odd prime factors up to the square root
        uint64_t count = 1;
        for (; n % p == 0; n /= p)
            ++count;
        total *= count;
    }

    if (n > 1)
        total *= 2; // If n > 1 then it's prime

    return total;
}

string p_factors (uint64_t num) {
    ostringstream os;

    for (uint64_t k = 2; k * k <= num; k++) {
        int ex = 0;

        while (num % k == 0) {
            num /= k;
            ex++;
        }

        if (ex > 0) {
            os << k;
            if (ex > 1) os << "^" << ex;
            if (num > 1) os << " * ";
        }
    }

    if (num > 1) os << to_string(num);
    return os.str();
}

bool is_prime (int num) {

    if (num <= 3) return true;
    if (num % 2 == 0 || num % 3 == 0) return false;

    for (int i = 5; i <= sqrt(num); i += 6)
        if (num % i == 0 || num % (i + 2) == 0)
            return false;

    return true;
}
vector<uint64_t> factorize (uint64_t n) {

    vector<uint64_t> factors;

    for (uint64_t k = 2; k < n; k++)
        if (n % k == 0)
            factors.push_back(k);

    return factors;
}

uint64_t fibonacci (uint64_t n) {
    if (n == 0) return 0;
    if (n == 1) return 1;
    return fibonacci (n - 1) + fibonacci (n - 2);
}
uint64_t sumdig (uint64_t num) {
    uint64_t sum = 0;
    while (num) {
        sum += num % 10;
        num /= 10;
    }
    return sum;
}

string collatz (uint64_t n) {

    string os;

    while (n != 1) {
        os += to_string (n) + " -> ";
        n = (n % 2 == 0) ? n * 0.5 : 3 * n + 1;
    }

    return os + "1";
}

int pyramidsum (string file) {
    vector<vector<int>> tri = getfile(file);

    for (int y = (tri.size() - 2); y >= 0; y--) {
        for (int x = 0; x <= y; x++) {
            tri[y][x] += max (tri[y + 1][x], tri[y + 1][x + 1]);
        }
    }

    return tri[0][0];
}

int gcd (int a, int b) { return b == 0 ? a : gcd (b, a % b); }

using vertex = pair<int, pair<int,int>>;

int main () {

    auto start = std::chrono::high_resolution_clock::now();

    uint64_t num = 2520;
    int sum = 0;

    vector<int> path = {131,201,96,342,746,422,121,37,331};

    vector<vector<int>> grid = {
      {131,673,234,103,18},
      {201,96,342,965,150},
      {630,803,746,422,111},
      {537,699,497,121,956},
      {805,732,524,37,331}};

      grid = getfile("p081_matrix.txt");
    int size = grid.size();
    pair<int,int> exit = {size-1, size-1 };
    const vector<pair<int,int>> compass = {{0,1}, {1,0}};

    priority_queue<vertex, vector<vertex>, greater<vertex>> q1;
    vector<vector<int>> hist (size, vector<int> (size));

    q1.push({grid[0][0], {0,0}});

    while (!q1.empty()) {

        auto [cost, u] = q1.top();
        q1.pop();

        hist[u.second][u.first] = cost;

        if (u == exit) break;

        for (auto dir : compass) {
            int nx = u.first + dir.first;
            int ny = u.second + dir.second;

            if (nx < size && ny < size) {
                vertex nxv = {cost + grid[ny][nx], {nx, ny}};
                q1.push(nxv);
            }
        }

    }

    cout <<  hist[size-1][size-1];

     /*
    1 2 3 5 7 11 13 17 19
    4 = 2²
    6 = 2 * 3
    8 = 2³
    9 = 3²
    10 = 2 * 5
    12 = 2² * 3
    14 = 2 * 7
    15 = 3 * 5
    16 = 2⁴
    18 = 2 * 9
    20 = 2² * 5

    */

/*
Pentagonal numbers are generated by the formula, Pn = n(3n−1) / 2. The first ten pentagonal numbers are:

1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

It can be seen that P4 + P7 = 22 + 70 = 92 = P8.
However, their difference, 70 − 22 = 48, is not pentagonal.

Find the pair of pentagonal numbers, Pj and Pk,
for which their sum and difference are pentagonal and D = |Pk − Pj| is minimised;
what is the value of D?

    for (uint64_t k = 1; k < 13; k++) {
        uint64_t pn = k * (3 * k - 1) / 2;
        //cout << pn << " ";
    }
*/


/*
    for (uint64_t k = 1; k < 30; k++) {
        sum *= 2;
        uint64_t nd = sumdig (sum);
        //cout << sum << " ";
        //cout << k << " => "<< sum << " : " << nd << " " << nd / 2 << "\n";
    }
*/

    auto end = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> elapsed = end - start;
    std::cout << "\nProcess took " << elapsed.count()  << " ms" << std::endl;
}
